-- ============================================================================
-- PROJECT VERIFICATION: Complete Gold Collection Workflow (Happy Path)
-- Verifies: Find partner → Pickup gold → Transport to deposit → Score
-- 
-- Based on Professor's method (new.md) + Project requirements (README.md)
-- Simplified to verify SUCCESSFUL coordination (no timeouts, no competition)
-- Sufficient for demonstrating protocol correctness in project report
-- ============================================================================

-- ----------------------------------------------------------------------------
-- CONFIGURATION
-- ----------------------------------------------------------------------------

-- Two robots only (minimum for project requirement)
datatype RobotID = R1 | R2

-- ----------------------------------------------------------------------------
-- CHANNELS
-- ----------------------------------------------------------------------------

channel tock

-- Communication (messages have 1-tick delay)
channel found : RobotID                -- Finder announces gold
channel response : RobotID             -- Helper offers help
channel ack : RobotID                  -- Finder selects helper
channel here : RobotID                 -- Helper at opposite position
channel ack2 : RobotID                 -- Finder confirms coordination

-- Physical actions
channel move_to_gold : RobotID         -- Move to gold position (INDEPENDENT)
channel pickup                         -- Both pickup together (SYNCHRONIZED)
channel move_to_deposit                -- Both move toward deposit (SYNCHRONIZED)
channel deposit                        -- Both deposit at deposit point (SYNCHRONIZED)
channel score                          -- Success! Gold scored (SYNCHRONIZED)

-- ----------------------------------------------------------------------------
-- FINDER ROBOT (R1)
-- ----------------------------------------------------------------------------

Finder = 
  found.R1 ->                          -- 1. Announce found gold
  WaitResponse

WaitResponse =
  response.R2 ->                       -- 2. Get helper response
    ack.R2 ->                          -- 3. Select R2 as helper
    WaitHere
  []
  tock -> WaitResponse

WaitHere =
  here.R2 ->                           -- 4. Helper signals arrival
    ack2.R2 ->                         -- 5. Confirm ready
    move_to_gold.R1 ->                 -- 6. Finder moves to gold
    WaitPickup
  []
  tock -> WaitHere

WaitPickup =
  pickup ->                            -- 7. PICKUP together!
    Transport
  []
  tock -> WaitPickup

-- NEW: Transport gold to deposit
Transport =
  move_to_deposit ->                   -- 9. Move together to deposit
    deposit ->                         -- 10. Deposit gold
    score ->                           -- 11. SUCCESS! Point scored
    SKIP

-- ----------------------------------------------------------------------------
-- HELPER ROBOT (R2)
-- ----------------------------------------------------------------------------

Helper = Exploring

Exploring =
  found.R1 ->                          -- 1. Receive found announcement
    response.R2 ->                     -- 2. Offer to help
    WaitAck
  []
  tock -> Exploring

WaitAck =
  ack.R2 ->                            -- 3. Got selected!
    here.R2 ->                         -- 4. Signal arrival at opposite
    WaitAck2
  []
  tock -> WaitAck

WaitAck2 =
  ack2.R2 ->                           -- 5. Get confirmation
    move_to_gold.R2 ->                 -- 6. Move to gold
    pickup ->                          -- 7. PICKUP together!
    Transport
  []
  tock -> WaitAck2

-- ----------------------------------------------------------------------------
-- MESSAGE DELAY (1 tick delay)
-- ----------------------------------------------------------------------------

-- Simple delay buffers (no bounded constraint for simplicity)
DelayFound = 
  found?id -> tock -> found.id -> DelayFound
  [] tock -> DelayFound

DelayResponse = 
  response?id -> tock -> response.id -> DelayResponse
  [] tock -> DelayResponse

DelayAck = 
  ack?id -> tock -> ack.id -> DelayAck
  [] tock -> DelayAck

DelayHere = 
  here?id -> tock -> here.id -> DelayHere
  [] tock -> DelayHere

DelayAck2 = 
  ack2?id -> tock -> ack2.id -> DelayAck2
  [] tock -> DelayAck2

-- ----------------------------------------------------------------------------
-- SYSTEM
-- ----------------------------------------------------------------------------

-- Message channels (delayed)
MsgChannels = {| found, response, ack, here, ack2 |}

-- Physical actions  
-- move_to_gold: NOT synchronized (each robot moves independently at different times)
-- pickup/deposit/score: Synchronized (must happen together)
ActionChannels = {| pickup, move_to_deposit, deposit, score |}

-- All synchronized events
AllChannels = union(MsgChannels, union(ActionChannels, {| tock |}))

-- Combine robots (sync on pickup/deposit/score + tock only)
-- move_to_gold is independent - Finder and Helper move at different times
Robots = Finder [| union(ActionChannels, {| tock |}) |] Helper

-- Combine all delays
Delays = 
  DelayFound
  [| {| tock |} |]
  (DelayResponse
   [| {| tock |} |]
   (DelayAck
    [| {| tock |} |]
    (DelayHere
     [| {| tock |} |]
     DelayAck2)))

-- System: Robots + Message delays
System = 
  Robots
  [| union(MsgChannels, {| tock |}) |]
  Delays

-- ----------------------------------------------------------------------------
-- ASSERTIONS
-- ----------------------------------------------------------------------------

-- Test 1: No deadlock
assert System :[deadlock free [F]]

-- Test 2: Eventually pickup happens (liveness)
PickupSpec = pickup -> STOP [] tock -> PickupSpec
assert PickupSpec [T= System

-- Test 3: Eventually score happens (mission success!)
ScoreSpec = score -> STOP [] tock -> ScoreSpec
assert ScoreSpec [T= System

-- ============================================================================
-- EXPECTED RESULTS:
--
-- Test 1 (Deadlock): PASS - no deadlock
-- Test 2 (Pickup): PASS - robots eventually pickup gold
-- Test 3 (Score): PASS - robots eventually deposit and score!
--
-- If ALL THREE PASS → Protocol works for project requirements! ✓
--
-- Expected workflow:
-- 1. R1 finds gold, announces (found)
-- 2. R2 offers help (response - delayed 1 tick)
-- 3. R1 selects R2 (ack - delayed 1 tick)
-- 4. R2 moves to opposite, signals (here - delayed 1 tick)
-- 5. R1 confirms ready (ack2 - delayed 1 tick)
-- 6. R1 moves to gold INDEPENDENTLY (move_to_gold.R1)
-- 7. R2 receives ack2, moves to gold INDEPENDENTLY (move_to_gold.R2)
-- 8. Both pickup SYNCHRONIZED (pickup - must wait for each other)
-- 9. Both move to deposit SYNCHRONIZED (move_to_deposit)
-- 10. Both deposit SYNCHRONIZED (deposit)
-- 11. Score! ✓
--
-- CRITICAL FIX APPLIED:
-- - move_to_gold is INDEPENDENT (not in ActionChannels)
-- - Each robot moves to gold separately at different times
-- - Only pickup/deposit/score are synchronized
--
-- LIMITATIONS (Simplified for 2-day deadline):
-- ✗ No timeouts (if helper doesn't respond, Finder waits forever)
-- ✗ No rejection handling (only 1 helper, always selected)
-- ✗ No multi-finder leader election (R1 is pre-assigned Finder)
-- ✓ Verifies SUCCESSFUL PATH only (sufficient for project demo)
--
-- State space: ~100-300 states, completes in 5-10 seconds
-- ============================================================================
