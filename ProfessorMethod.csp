-- ============================================================================
-- CSP MODEL: Professor's Finder/Helper Protocol
-- Based on new.md specification
-- Purpose: Verify correctness of finder/helper coordination with delays
--
-- ULTRA-SIMPLIFIED FOR FAST VERIFICATION:
-- - 2 robots only
-- - NO message indices (not needed for 2 robots)
-- - NO timeouts (happy path only)
-- - NO retries (simplified)
-- - Fixed 1-tick message delay (simple)
-- - NO responders set (pick first response immediately)
-- - NO queue buffers (simple delay per message)
--
-- CRITICAL FIXES APPLIED:
-- Fix #1: WaitAck2 accepts ack2/MovingToGold in ANY order (race condition)
-- Fix #2: send_*/recv_* channels force messages through delay buffers
-- Fix #3: SUCCESS instead of STOP (allows tock after completion)
-- Fix #4: Finder can tock before becoming finder (prevents initial deadlock)
--
-- Goal: Fast verification (~100-500 states, 5-15 seconds)
-- Keeps protocol logic: Found→Response→Ack→Here→Ack2→Pickup→Transport→Deposit→Score
-- ============================================================================

-- ----------------------------------------------------------------------------
-- CONFIGURATION
-- ----------------------------------------------------------------------------

datatype RobotID = R1 | R2

-- ----------------------------------------------------------------------------
-- CHANNELS
-- ----------------------------------------------------------------------------

channel tock

-- Communication channels (delayed via buffers)
-- Separate send/recv to force messages through delay buffers
channel send_found, recv_found : RobotID
channel send_response, recv_response : RobotID
channel send_ack, recv_ack : RobotID
channel send_here, recv_here : RobotID
channel send_ack2, recv_ack2 : RobotID

-- Observable events (synchronized, no delay)
channel obs : ObsEvent
datatype ObsEvent
  = BecameFinder.RobotID
  | BecameHelper.RobotID
  | MovingToGold.RobotID
  | PickupSuccess
  | MovingToDeposit
  | DepositSuccess
  | Scored

-- ----------------------------------------------------------------------------
-- SUCCESS STATE (finished but can still tick)
-- ----------------------------------------------------------------------------

-- A process that has finished successfully and just idles
SUCCESS = tock -> SUCCESS

-- ----------------------------------------------------------------------------
-- ROBOT AS FINDER (R1)
-- ----------------------------------------------------------------------------

Finder = 
  obs.BecameFinder.R1 ->
  send_found.R1 ->               -- Announce found gold
  WaitResponse
  []
  tock -> Finder                 -- Can idle while waiting to become finder

WaitResponse =
  recv_response.R2 ->            -- Wait for helper to respond
    send_ack.R2 ->               -- Send ack to helper
    WaitHere
  []
  tock -> WaitResponse

WaitHere =
  recv_here.R2 ->                -- Helper signals arrival
    obs.MovingToGold.R1 ->       -- Finder moves to gold
    send_ack2.R2 ->              -- Send ack2 confirmation
    WaitPartnerMove
  []
  tock -> WaitHere

WaitPartnerMove =
  obs.MovingToGold.R2 ->         -- See partner move to gold
    obs.PickupSuccess ->         -- Both pickup together!
    Transport
  []
  tock -> WaitPartnerMove

Transport =
  obs.MovingToDeposit ->         -- Both move to deposit
  Deposit

Deposit =
  obs.DepositSuccess ->          -- Both deposit gold
  Score

Score =
  obs.Scored ->                  -- Group scores!
  SUCCESS                        -- Changed from STOP

-- ----------------------------------------------------------------------------
-- ROBOT AS HELPER (R2)
-- ----------------------------------------------------------------------------

Helper = Exploring

Exploring =
  recv_found.R1 ->               -- Receive found announcement
    send_response.R2 ->          -- Send response to offer help
    WaitAck
  []
  tock -> Exploring

WaitAck =
  recv_ack.R2 ->                 -- Ack for THIS helper!
    obs.BecameHelper.R2 ->       -- Become helper
    MoveToOpposite
  []
  tock -> WaitAck

MoveToOpposite =
  send_here.R2 ->                -- Announce "I'm at opposite position"
  WaitAck2

-- FIX #1: Accept ack2 and MovingToGold in ANY order (race condition fix)
WaitAck2 =
  -- Case 1: Receive ack2 first
  recv_ack2.R2 ->
    WaitForFinderMove
  -- Case 2: Observe move first
  []
  obs.MovingToGold.R1 ->
    WaitForFinalAck
  []
  tock -> WaitAck2

-- Helper state: Got ack2, now waiting for move
WaitForFinderMove =
  obs.MovingToGold.R1 ->
    MoveAndPickup
  []
  tock -> WaitForFinderMove

-- Helper state: Got move, now waiting for ack2
WaitForFinalAck =
  recv_ack2.R2 ->
    MoveAndPickup
  []
  tock -> WaitForFinalAck

-- Both events seen, now helper moves
MoveAndPickup =
  obs.MovingToGold.R2 ->
  obs.PickupSuccess ->
  HelperTransport

HelperTransport =
  obs.MovingToDeposit ->         -- Both move to deposit
  HelperDeposit

HelperDeposit =
  obs.DepositSuccess ->          -- Both deposit gold
  HelperScore

HelperScore =
  obs.Scored ->                  -- Group scores!
  SUCCESS                        -- Changed from STOP

-- ----------------------------------------------------------------------------
-- COMPLETE ROBOT PROCESSES
-- ----------------------------------------------------------------------------

-- Robot 1 is Finder
ROBOT_1 = Finder

-- Robot 2 is Helper
ROBOT_2 = Helper

-- ----------------------------------------------------------------------------
-- MESSAGE DELAY BUFFERS (1-tick delay per channel)
-- FIX #2: Use send_* and recv_* to force messages through buffers
-- ----------------------------------------------------------------------------

DelayFound =
  send_found?id -> tock -> tock -> recv_found.id -> DelayFound
  [] tock -> DelayFound

DelayResponse =
  send_response?id -> tock -> tock -> recv_response.id -> DelayResponse
  [] tock -> DelayResponse

DelayAck =
  send_ack?id -> tock -> tock -> recv_ack.id -> DelayAck
  [] tock -> DelayAck

DelayHere =
  send_here?id -> tock -> tock -> recv_here.id -> DelayHere
  [] tock -> DelayHere

DelayAck2 =
  send_ack2?id -> tock -> tock -> recv_ack2.id -> DelayAck2
  [] tock -> DelayAck2

-- ----------------------------------------------------------------------------
-- SYSTEM COMPOSITION
-- FIX #2: Updated channel sets for send/recv pattern
-- ----------------------------------------------------------------------------

-- Message channels (delayed)
SendChannels = {| send_found, send_response, send_ack, send_here, send_ack2 |}
RecvChannels = {| recv_found, recv_response, recv_ack, recv_here, recv_ack2 |}
MsgChannels = union(SendChannels, RecvChannels)

-- Observable events (synchronized, no delay)
ObsChannels = {| obs |}

-- Combine robots (sync on obs events + tock, NOT on messages)
Robots = ROBOT_1 [| union(ObsChannels, {| tock |}) |] ROBOT_2

-- Combine all delays
Delays = 
  DelayFound
  [| {| tock |} |]
  (DelayResponse
   [| {| tock |} |]
   (DelayAck
    [| {| tock |} |]
    (DelayHere
     [| {| tock |} |]
     DelayAck2)))

-- System: Robots with delayed messages
System = 
  Robots
  [| union(MsgChannels, {| tock |}) |]
  Delays

-- ----------------------------------------------------------------------------
-- SPECIFICATIONS
-- ----------------------------------------------------------------------------

-- Spec 1: Eventually pickup happens (liveness)
PickupSpec = 
  obs.PickupSuccess -> STOP
  [] obs.BecameFinder?id -> PickupSpec
  [] obs.BecameHelper?id -> PickupSpec
  [] obs.MovingToGold?id -> PickupSpec
  [] obs.MovingToDeposit -> PickupSpec
  [] obs.DepositSuccess -> PickupSpec
  [] obs.Scored -> PickupSpec
  [] tock -> PickupSpec

-- Spec 2: Eventually score happens (full workflow)
ScoreSpec = 
  obs.Scored -> STOP
  [] obs.BecameFinder?id -> ScoreSpec
  [] obs.BecameHelper?id -> ScoreSpec
  [] obs.MovingToGold?id -> ScoreSpec
  [] obs.PickupSuccess -> ScoreSpec
  [] obs.MovingToDeposit -> ScoreSpec
  [] obs.DepositSuccess -> ScoreSpec
  [] tock -> ScoreSpec

-- ----------------------------------------------------------------------------
-- ASSERTIONS (For Project Verification)
-- ----------------------------------------------------------------------------

-- TEST 1: No deadlock (system never gets stuck)
assert System :[deadlock free [F]]

-- TEST 2: Eventually pickup happens (robots successfully pickup gold)
assert PickupSpec [T= System

-- TEST 3: Eventually score happens (complete workflow to deposit)
assert ScoreSpec [T= System

-- ============================================================================
-- EXPECTED RESULTS (FAST VERIFICATION)
-- ============================================================================

{-
ULTRA-SIMPLIFIED MODEL for fast verification (like ProjectVerification.csp)

WORKFLOW VERIFIED:
1. Finder finds gold and announces (found message - delayed)
2. Helper responds (response message - delayed)
3. Finder selects helper (ack message - delayed)
4. Helper moves to opposite, signals (here message - delayed)
5. Finder moves to gold, confirms (MovingToGold obs, ack2 message - delayed)
6. Helper moves to gold (MovingToGold obs)
7. Both pickup gold together (PickupSuccess obs) ← PROJECT
8. Both transport to deposit (MovingToDeposit obs) ← PROJECT
9. Both deposit gold (DepositSuccess obs) ← PROJECT
10. Score! (Scored obs) ← PROJECT SUCCESS

Expected FDR4 Results:

TEST 1: Deadlock free - SHOULD PASS
   - No deadlock in happy path
   - System completes successfully

TEST 2: Pickup happens - SHOULD PASS
   - Robots coordinate and pickup gold
   - 2-robot synchronization works

TEST 3: Score happens - SHOULD PASS
   - Complete workflow succeeds
   - Full project requirement verified

If ALL THREE PASS → Protocol works! ✓

Simplifications Applied (for speed):
- NO timeouts/retries (happy path only)
- NO message indices (not needed for 2 robots)
- Simple 1-tick delays (not queue-based)
- Fixed roles (R1=Finder, R2=Helper)

CRITICAL FIXES APPLIED:
✅ Fix #1: WaitAck2 state machine accepts events in ANY order
   - Prevents race condition between ack2 message and MovingToGold observation
   - Helper can receive these events in either order without deadlock
✅ Fix #2: send_*/recv_* channel separation
   - Forces all messages through delay buffers
   - Prevents instantaneous message bypass deadlock
✅ Fix #3: SUCCESS instead of STOP
   - Robots end in SUCCESS (can still tock) not STOP (can't tock)
   - Prevents deadlock with infinite delay buffers
   - System can idle after protocol completes
✅ Fix #4: Finder can tock before becoming finder
   - Allows Finder to idle while waiting to start
   - Prevents initial deadlock with Exploring process

State space: ~100-500 states (FAST!)
Verification time: 5-15 seconds expected
-}
